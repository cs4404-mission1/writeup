# Defense

## Overview

We discovered 5 vulnerabilities in the ShueWorld election system:

**V-CA-01**: Local file inclusion via directory traversal in /static path parameter

**V-CA-02**: DNS challenge uses a constant UDP source port

**V-CA-03**: Deterministic PRNG and constant seed for generating DNS message ID in DNS challenge

**V-NET-01**: Sensitive information disclosure via DNS

**V-NET-02**: Unprotected VLAN trunk ports




### Mitigating V-CA-01: Local file inclusion via directory traversal in /static path parameter

The `/static` endpoint accepts a `path` parameter to retrieve static assets. It doesn't correctly sanitize input which allows an attacker to traverse the filesystem with a `..%2f` or `../` character sequence. We suggest using the [path/filepath](https://pkg.go.dev/path/filepath) module from the standard library to sanitize and verify the path against path and symlink traversal before sending the file to the client.

```go
func sanitizePath(path string) (string, error) {
  path := filepath.Clean(path)
  r, err := filepath.EvalSymlinks(path)
  if err != nil {
     return c, errors.New("invalid path specified")
  }
  return r, nil
}
```



### Mitigating V-CA-02: DNS challenge uses a constant UDP source port

The `dnsChallenge` function uses a hardcoded outbound UDP port of 50000. This reduces entropy required to forge DNS answers towards the CA. We propose modifying the `dnsChallenge` function to allow the system to choose a random, ephemeral port number for each DNS query:

```go
- conn, err := net.DialUDP(
- 	"udp",
- 	&net.UDPAddr{IP: local, Port: 50000},
- 	&net.UDPAddr{IP: remote, Port: 53},
- )
- if err != nil {
- 	return "", err
- }
- defer conn.Close()
- 
client := dns.Client{Net: "udp"}
- r, _, err := client.ExchangeWithConn(m, &dns.Conn{Conn: conn})
+ r, _, err := client.Exchange(m, remote.String()+":53")
if err != nil {
	return "", err
}
```



### Mitigating V-CA-03: Deterministic PRNG and constant seed for generating DNS message ID in DNS challenge

The `dnsChallenge` and `randHex` functions use the Go standard library `math/rand` module.  `math/rand` is deterministic, meaning given a known seed, the output is repeatably predictable. Furthermore, the PRNG is never manually seeded. The random source uses "precooked" values generated by [gen_cooked.go from math/rand](https://cs.opensource.google/go/go/+/refs/tags/go1.19.3:src/math/rand/gen_cooked.go), so with a default seed, all numbers are trivially and repeatably predictable.

> This package's outputs might be easily predictable regardless of how it's seeded. For random numbers suitable for security-sensitive work, see the crypto/rand package. [pkg.go.dev math/rand](https://pkg.go.dev/math/rand)

RFC 5452 advises the use of a high quality cryptographically secure pseudo random number generator (CSPRNG) to mitigate this vulnerability.

> Proper unpredictability can be achieved by employing a high quality
> (pseudo-)random generator, as described in RFC4086. [RFC 5452 section 9.2](https://www.rfc-editor.org/rfc/rfc5452#section-9.2)

We propose removing `math/rand` in favor of `crypto/rand` because the CA's entropy source has no reason to be deterministic. An alternate implementation of `randHex` using `crypto/rand` could be a drop in replacement for the existing `randHex` function.

```go
- // randHex generates a random 32 character hex string
- func randHex() string {
- 	const letters = "0123456789abcdef"
- 	b := make([]byte, 32)
- 	for i := range b {
- 		b[i] = letters[rand.Intn(len(letters))]
- 	}
- 	return string(b)
- }
+ // randHex generates a secure random 32 character hex string
+ func randHex() string {
+ 	b := make([]byte, 16)
+ 	if _, err := rand.Read(b); err != nil {
+ 		panic(err)
+ 	}
+ 	return fmt.Sprintf("%x", b)
+ }
```

The `dnsChallenge` function used to make an outbound DNS query uses the `Intn` function from `math/rand` to generate a DNS message ID. This is similarly insecure because it enables the prediction of DNS message IDs and together with V-CA-02, effectively decreases entropy to make DNS response forgery possible. Replacing the use of `rand.Intn` with the `dns.Id` function mitigates this vulnerability by using a secure random source from `crypto/rand`.

```go
- m.Id = uint16(rand.Intn(65535))
+ m.Id = dns.Id()
```

The `dns` module uses `binary.Read` to read a uint16 from `crypto/rand`' `Reader` interface.

```go
// Id by default returns a 16-bit random number to be used as a message id. The
// number is drawn from a cryptographically secure random number generator.
// This being a variable the function can be reassigned to a custom function.
// For instance, to make it return a static value for testing:
//
//	dns.Id = func() uint16 { return 3 }
var Id = id

// id returns a 16 bits random number to be used as a
// message id. The random provided should be good enough.
func id() uint16 {
	var output uint16
	err := binary.Read(rand.Reader, binary.BigEndian, &output)
	if err != nil {
		panic("dns: reading random id failed: " + err.Error())
	}
	return output
}
```

*Source: github.com/miekg/dns@v1.1.50/msg.go*



### Mitigating V-NET-01: Internal information disclosure via DNS

Potentially sensitive internal information like the IP address of the internal key server should not be visible in public DNS records. We advise using a private, internal resolver for internal names, and refrain from entering private data in public DNS.

Furthermore, allowing private address space in public DNS is dangerous because it enables [DNS rebinding](https://unit42.paloaltonetworks.com/dns-rebinding/). We advise modifying the resolver's `unbound` configuration file to prohibit responding with private address space for DNS rebinding protection. This mitigation includes covering IPv4 loopback, link-local, and RFC 1918 shared private address space.

```
# Append to /etc/unbound/unbound.conf
private-address: 127.0.0.0/8
private-address: 10.0.0.0/8
private-address: 172.16.0.0/12
private-address: 169.254.0.0/16
private-address: 192.168.0.0/16
```



### Mitigating V-NET-02: Unprotected VLAN trunk ports

The VLAN between the API and key server is enabled on all VM virtual trunk ports, which allows an attacker to hop into the VLAN, therefore defeating any security that would be afforded by these ts being in an isolated network. We recommend using a managed virtual switch such as openvswitch with a secure trunk policy preventing 802.1Q tagged frames from being forwarded to any host except when originating from the key server or API.

